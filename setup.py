# from distribute_setup import use_setuptools
# use_setuptools()

from pathlib import Path
import sys
import numpy as np
from setuptools import setup
from setuptools.extension import Extension
from distutils.version import StrictVersion

# from distutils.core import setup, Extension

from Cython.Build import cythonize

ext = ".pyx"

include_dirs = [np.get_include()]
library_dirs = []
if StrictVersion(np.__version__) < StrictVersion("1.21"):
    lapack_info = np.__config__.lapack_mkl_info
    include_dirs += [lapack_info["include_dirs"]]
    library_dirs += [lapack_info["library_dirs"]]
else:
    # lapack_info = np.__config__.lapack_opt_info
    build_deps = np.show_config("dicts")["Build Dependencies"]
    lapack_info = build_deps["lapack"]
    if (lapack_includes := lapack_info["include directory"]) != "unknown":
        include_dirs += [lapack_includes]
    if (lapack_libs := lapack_info["lib directory"]) != "unknown":
        library_dirs += [lapack_libs]
    blas_info = build_deps["blas"]
    if (blas_includes := blas_info["include directory"]) != "unknown":
        include_dirs += [blas_includes]
    if (blas_libs := blas_info["lib directory"]) != "unknown":
        library_dirs += [blas_libs]
# not all path separators are created equal
include_dirs = [str(Path(directory)) for directory in include_dirs]
library_dirs = [str(Path(directory)) for directory in library_dirs]

static_libraries = [
    # "mkl_rt"
    # "mkl_intel_lp64",
    # "mkl_tbb_thread",
    # "mkl_core",
    # "tbb",
]
static_lib_dir = library_dirs[0]
if sys.platform == "win32":
    extensions = []
    extra_link_args = []
    extra_compile_args = []
    include_dirs += [r'-I"%MKLROOT%"\include']
else:  # POSIX
    extra_compile_args = ["-std=c99"]
    extra_link_args = [
        # "-I",
        # # "(intel's dir)/intel/compilers_and_libraries_2016.3.210/linux/mkl/include",
        # "/opt/intel/mkl/include",
        # "-L",
        # # "(intel's dir)/intel/mkl/lib/intel64/libmkl_mc.so",
        # "/opt/intel/oneapi/mkl/2023.2.0/lib/intel64/libmkl_mc.so.2",
        "-mkl",
    ]

    extensions = [
        Extension(
            "weathercop.normal_conditional",
            ["weathercop/normal_conditional" + ext],
            include_dirs=include_dirs,
            library_dirs=library_dirs,
        ),
    ]

# autogenerated functions
ufuncs_path = Path("./weathercop/ufuncs")
auto_exts = [
    Extension(
        f"weathercop.ufuncs.{name.stem}",
        [str(name), str(name.parent / name.stem[: -len("0")]) + "code_0.c"],
        include_dirs=include_dirs + [str(ufuncs_path)],
        extra_link_args=extra_link_args,
        extra_compile_args=extra_compile_args,
    )
    for name in ufuncs_path.glob("*.pyx")
]
# build_ext --inplace misses subdirs?
for name in ufuncs_path.glob("*.pyx"):
    Path(name.absolute().parent / name.stem).mkdir(exist_ok=True)
extensions += auto_exts

extensions += [
    Extension(
        "weathercop.cvine",
        [str(Path("weathercop/cvine")) + ext],
        include_dirs=include_dirs,
        library_dirs=library_dirs,
        extra_compile_args=extra_compile_args,
    ),
    Extension(
        "weathercop.cinv_cdf",
        [str(Path("weathercop/cinv_cdf")) + ext],
        include_dirs=include_dirs,
        library_dirs=library_dirs,
        extra_compile_args=extra_compile_args,
    ),
]

setup(
    name="weathercop",
    version="0.1",
    packages=["weathercop", "weathercop.ufuncs"],
    ext_modules=cythonize(extensions),
    include_dirs=include_dirs,
    install_requires=[
        "numpy>=1.26",
        "scipy",
        "matplotlib",
        "sympy",
        "cartopy",
        "networkx",
        "tqdm",
        "timezonefinder",
        "mkl",
        "numexpr",
        "cython",
        "pandas",
        "xarray",
        "netcdf4",
        "dill",
    ],
    package_data={
        # If any package contains *.txt or *.rst files, include them:
        # '': ['*.txt', '*.dat', '*.met', "*.rst", "*.pyx", "*.c"],
        "": ["*.pyx", "*.pyd", "*.so", "sympy_cache.*"],
        # 'doc': ['*.html', '*.rst'],
    },
    include_package_data=True,
    # metadata for upload to PyPI
    author="Dirk Schlabing",
    author_email="dirk.schlabing@iws.uni-stuttgart.de",
    description="A Copula-based Weather Generator",
    license="BSD",
    keywords=("weather generator copula phase randomization"),
    # # could also include long_description, download_url, classifiers, etc.
    # long_description=\
    #     """asdf"""
)
